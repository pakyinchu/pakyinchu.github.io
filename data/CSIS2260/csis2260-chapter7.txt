Frame is a fixed-length block of main memory
Page is a fixed-length block of data that resides in secondary memory (such as disk)
Page is a page of data may temporarily be copied into a frame of main memory
Segment is a variable-length block of data that resides in secondary memory
Segment is an entire segment may temporarily be copied into an available region of main memory (segmentation) or the segment may be divided into pages which can be individually copied into main memory (combined segmentation and paging)
Memory Management Requirements Memory management is intended to satisfy the following requirements: Relocation, Protection, Sharing, Logical organization, Physical organization, Relocation
Relocation: Programmers typically do not know in advance which other programs will be resident in main memory at the time of execution of their program
Relocation: Active processes need to be able to be swapped in and out of main memory in order to maximize processor utilization
Relocation: Specifying that a process must be placed in the same memory region when it is swapped back in would be limiting
Relocation: May need to relocate the process to a different area of memory
Relocation: OS must be able to translate the memory references in the code of the program into actual physical memory addresses, reflecting the current location of the program in main memory
Protection: Processes need to acquire permission to reference memory locations for reading or writing purposes
Protection: Location of a program in main memory is unpredictable
Protection: Memory references generated by a process must be checked at run time
Protection: Mechanisms that support relocation also support protection
Sharing: Advantageous to allow each process access to the same copy of the program rather than have their own separate copy
Sharing: Memory management must allow controlled access to shared areas of memory without compromising protection
Sharing: Mechanisms used to support relocation support sharing capabilities
Logical Organization: Memory is organized as linear address space
Logical Organization: Programs are written in modules
Logical Organization: Modules can be written and compiled independently
Logical Organization: Different degrees of protection given to modules (read-only, execute-only)
Logical Organization: Sharing on a module level corresponds to the user’s way of viewing the problem
Logical Organization: Segmentation is the tool that most readily satisfies requirements
Physical Organization: Cannot leave the programmer with the responsibility to manage Memory
Physical Organization: Memory available for a program plus its data may be insufficient
Physical Organization: Programmer does not know how much space will be available
Physical Organization: Overlaying allows various modules to be assigned the same region of memory but is time consuming to program
Memory Partitioning: Memory management brings processes into main memory for execution by the processor
Memory Partitioning: Involves virtual memory
Memory Partitioning: Based on segmentation and paging
Memory Partitioning: Partitioning is used in several variations in some now-obsolete operating systems and it does not involve virtual memory
Fixed Partitioning: Equal-size partitions
Fixed Partitioning: any process whose size is less than or equal to the partition size can be loaded into an available partition
Fixed Partitioning: The operating system can swap out a process if all partitions are full and no process is in the Ready or Running state
Disadvantages of Fixed Partitioning: A program may be too big to fit in a partition
Disadvantages of Fixed Partitioning: Program needs to be designed with the use of overlays
Disadvantages of Fixed Partitioning: Main memory utilization is inefficient
Disadvantages of Fixed Partitioning: Any program, regardless of size, occupies an entire partition
Disadvantages of Fixed Partitioning: Internal fragmentation; Wasted space due to the block of data loaded being smaller than the partition
Unequal Size Partitions: Using unequal size partitions helps lessen the problems
Unequal Size Partitions: programs up to 16M can be accommodated without overlays
Unequal Size Partitions: partitions smaller than 8M allow smaller programs to be accommodated with less internal fragmentation
Disadvantages of Unequal Size Partitions: The number of partitions specified at system generation time limits the number of active processes in the system
Disadvantages of Unequal Size Partitions: Small jobs will not utilize partition space efficiently
Dynamic Partitioning: Partitions are of variable length and number
Dynamic Partitioning: Process is allocated exactly as much memory as it requires
Dynamic Partitioning: This technique was used by IBM’s mainframe operating system, OS/MVT
Dynamic Partitioning: External Fragmentation; Memory becomes more and more fragmented; Memory utilization declines
Dynamic Partitioning: Compaction is a technique for overcoming external fragmentation
Dynamic Partitioning: With Compaction, OS shifts processes so that they are contiguous; Free memory is together in one block but it is time consuming and wastes CPU time
Placement Algorithms: Best-fit, First-fit, Next-fit
Placement Algorithms Best-fit: Chooses the block that is closest in size to the request
Placement Algorithms First-fit: Begins to scan memory from the beginning and chooses the first available block that is large enough
Placement Algorithms Next-fit: Begins to scan memory from the location of the last placement and chooses the next available block that is large enough
Relocation: When the fixed partition scheme (one process queue per partition) is used, we can expect a process will always be assigned to the same partition
Relocation: Whichever partition is selected when a new process is loaded will always be used to swap that process back into memory after it has been swapped out, in that case, a simple relocating loader can be used
Relocation: When the process is first loaded, all relative memory references in the code are replaced by absolute main memory addresses, determined by the base address of the loaded process
Relocation: In the case of equal-size partitions and in the case of a single process queue for unequal-size partitions, a process may occupy different partitions during the course of its life
Relocation: When a process image is first created, it is loaded into some partition in main memory; Later, the process may be swapped out
Relocation: When it is subsequently swapped back in, it may be assigned to a different partition than the last time; The same is true for dynamic Partitioning
Relocation: When compaction is used, processes are shifted while they are in main memory
Relocation: Thus, the locations referenced by a process are not fixed, they will change each time a process is swapped in or shifted
Addresses: Logical, Relative, Physical or Absolute
Addresses Logical: Reference to a memory location independent of the current assignment of data to memory
Addresses Logical: Need to translate into physical address before memory access can be achieved
Addresses Relative: A particular example of logical address, in which the address is expressed as a location relative to some known point
Addresses Physical or Absolute: Actual location in main memory
Address Translation: For programs that employ relative addresses, when the program is loaded, the base register is loaded with the starting address in main memory of the program
Address Translation: A “bounds” register stores the ending location of the program
Address Translation: When a relative address is encountered, the value in the base register is added to the relative address to produce an absolute address, then compared to the value in the bounds register
Paging: Partition memory into equal fixed-size chunks that are relatively small
Paging: Process is also divided into small fixed-size chunks of the same size
Pages are chunks of a process
Frames are available chunks of memory
Page Table is maintained by operating system for each process
Page Table contains the frame location for each page in the process
Processor must know how to access for the current process, a Page Table is used by processor to produce a physical address
Segmentation: A program can be subdivided into segments which may vary in length, but there is a maximum length
Segmentation: Addressing consists of two parts: Segment number and an offset
Segmentation: Similar to dynamic partitioning but eliminates internal fragmentation
Segmentation: Usually visible to programmer 
Segmentation: Provided as a convenience for organizing programs and data
Segmentation: Typically the programmer will assign programs and data to different segments
Segmentation: For purposes of modular programming the program or data may be further broken down into multiple segments
Segmentation: The principal inconvenience of this service is that the programmer must be aware of the maximum segment size limitation
Address Translation: Another consequence of unequal size segments is that there is no simple relationship between logical addresses and physical addresses
Address Translation steps 1: Extract the segment number as the leftmost n bits of the logical address
Address Translation steps 2: Use the segment number as an index into the process segment table to find the starting physical address of the segment
Address Translation steps 3: Compare the offset, expressed in the rightmost m bits, to the length of the segment. If the offset is greater than or equal to the length, the address is invalid
Address Translation steps 4: The desired physical address is the sum of the starting physical address of the segment plus the offset







